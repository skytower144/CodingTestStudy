//통계학

내 해결_:

#include <stdio.h>
#include <stdlib.h>
int compare(const void *a, const void *b)
{
	int num1 = *(int *)a;
	int num2 = *(int *)b;
	if(num1>num2)	return 1;
	if(num1<num2)	return -1;
	return 0;
}

int main(void)
{
	int N; int sum=0;
	int num[500001] = {0,};
	int binbin[500001] = {1, 0, };
	scanf("%d", &N);
	for(int t=0; t<N; t++)
	{
		scanf("%d", &num[t]);
		sum += num[t];
	}
	qsort(num,N,sizeof(int),compare);
	int size = num[N-1] - num[0];
	int a=0; int k=0;
	for(int i=1; i<N; i++)
	{
		if(num[i] == num[k])
			binbin[a]++;
		else if(num[i] != num[k])
		{
			k=i;
			a++;
			binbin[a]++;
		}
	}
	int max=0; int flag=0; int sum2=0; int most=0;
	for(int i=0; i<=a; i++)
	{
		sum2 += binbin[i];
		if(max<binbin[i])
		{
			max = binbin[i];
			most = num[sum2-1];
			flag=0;
		}
		else if(max == binbin[i])
		{
			if(flag==0)
				most = num[sum2-1];
			flag = 1;
		}
	}
	printf("%.lf\n", (double)sum/N);
	printf("%d\n", num[N/2]);
	printf("%d\n", most);	
	printf("%d\n", size);
	return 0;
}

----------------------------------------------------------------------------------------------------
카운팅 정렬을 이용한 해결방안: https://www.acmicpc.net/source/26022317

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int arr[500000];
int count[8001] = { 0, };
int num;

int init_arr() {
	int n,m;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%d", &m);
		count[m + 4000]++;				// 값 4000을 중심점으로 잡은 것임.
	}									// 음수가 존재하기 때문이다.
	return n;
}

void sort_arr() {
	int k = 0;
	int max_cnt = 0, cnt = 0;
	for (int i = 0; i < 8001; i++) {
		if (count[i] != 0) {
			if (max_cnt < count[i])
				max_cnt = count[i];
			for(int j=count[i];j>0;j--)
				arr[k++] = i - 4000;
		}
	}
	
	for (int i = 0; i < 8001; i++) {
		if (max_cnt == count[i] && cnt == 0) {
			num = i-4000;
			cnt++;
		}
		else if (max_cnt == count[i] && cnt == 1) {
			num = i-4000;
			break;
		}
	}

}

void print_ans(int n) {
	double sum = 0;
	
	for (int i = 0; i < n; i++) sum += arr[i];
	printf("%.f\n", sum / n*1.0);
	printf("%d\n", arr[(n) / 2]);
	printf("%d\n",num);
	printf("%d\n", arr[n - 1] - arr[0]);
}

int main() {
	int n;
	n=init_arr();
	sort_arr();
	print_ans(n);

	return 0;
}


해설):
count[0] ~ count[8000]
-4000 ~ 4000

count[0] 는 -4000을 대표
count[1] 는 1 - 4000 = -3999 을 대표
count[2] 는 2 - 4000 = -3998 을 대표
...
count[8000] 는 8000 - 4000 = 4000을 대표

해당되는 숫자들의 자리에 +1씩 채워준다.

<SORT>
count[0]~count[8000]을 하나씩 검토
값이 들어있다면
    최대최빈값 갱신
    값만큼 반복: arr[k++]에 차례대로 i-4000을 넣는다. 

arr[]을 완성시키면 
ex): {-3 -2 -2 -1 -1 } 식으로 채워졌을 것임.

그리고 max_cnt에는 최대최빈값이 있을 것임.
하지만 그 최대최빈값이 여러개가 존재할 가능성이 있으므로

다시 for문으로 count[0]~count[8000]을 하나씩 검토:

count[0]~count[8000]중 max_cnt만큼 채워져있는 칸을 찾아내야함.
만약 찾아냈을 시 해당 count[]가 대표하는 arr[] 안에 있을 값을 num에 넣고
cnt을 증가시킴.

그 이후에 max_cnt만큼 채워져있는 칸을 찾을 시 2번째 최대최빈값이므로
해당 count[]가 대표하는 arr[] 안에 있을 값을 num에 넣어서 갱신하고
for반복문을 빠져나온다.
이 시점에는 최대최빈값이 여러개 존재한다는 것이 증명되었고,
우리가 구하고자하는 최종값 num을 구했기 때문이다.


----------------------------------------------------------------------------------