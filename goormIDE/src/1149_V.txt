//RGB 거리_동적계획법 기초 문제
https://m.blog.naver.com/occidere/220785383050
-----------------------------------------------------------------------

#include <stdio.h>
int rgb[1001][4] = {0,};
int d[1001][4] = {0,};
int N;
int sum=0; int min;

int compare(int a, int b)
{
	if(a>b)
	{
		return b;
	}
	else
	{
		return a;
	}
}
int sol(int n)
{
	d[0][0] = rgb[0][0];
	d[0][1] = rgb[0][1];
	d[0][2] = rgb[0][2];
	
	for(int k=1; k<n; k++)
	{
		d[k][0] = compare(d[k-1][1], d[k-1][2]) + rgb[k][0];
		d[k][1] = compare(d[k-1][0], d[k-1][2]) + rgb[k][1];
		d[k][2] = compare(d[k-1][0], d[k-1][1]) + rgb[k][2];
	}
	min = d[n-1][0];
	if(d[n-1][1]<min)
		min = d[n-1][1];
	if(d[n-1][2]<min)
		min = d[n-1][2];
	return min;
}


int main()
{
	int k=0;
	scanf("%d", &N);
	for(int i=0; i<N; i++)
	{
		scanf("%d %d %d", &rgb[i][k],&rgb[i][k+1],&rgb[i][k+2]);
	}
	sol(N);
	printf("%d\n", min);

	return 0;
}

------------------------------------------------------------------------------

답이 되는 칸을 차례대로 가정해본 후
비교 후 진정한 답을 추출...

d[n-1][0]이 최종 답이 될 경우를 생각해본다.
d[n-1][0] = ( d[n-2][1] 혹은 d[n-2][2] 둘 중 값이 적은 것 ) + rgb[n-1][0]

축적해온 답을 바탕으로 최종 답을 추론...?
