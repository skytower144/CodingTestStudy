// 가장 긴 증가하는 수열 4 // 동적 계획법

#include <stdio.h>

int main()
{
	int num[1001] = {0,};
	int dp[1001] = {0,};
	int list[1001][1001] = {0,};
	int N;
	scanf("%d", &N);
	for(int i=0; i<N; i++)
	{
		scanf("%d", &num[i]); 
	}
	list[0][0] = 1;
	for(int i=1; i<N; i++)
	{
		int temp=-1;
		for(int k=0; k<i; k++)
		{
			if(num[k]<num[i] && dp[k] >= dp[i])
			{
				dp[i] = dp[k] + 1;
				temp = k;
			}
		}
		if(temp==-1)
		{
			list[i][i] = 1;
		}
		else
		{
			for(int a=0; a<=temp; a++)
			{
				list[i][a] = list[temp][a];
			}
			list[i][i] = 1;
		}
		
	}
	
	int max = -1;
	int maxNum;
	for(int i=0; i<N; i++)
	{
		if(max<dp[i])
		{
			max = dp[i];
			maxNum = i;
		}
	}
	printf("%d\n", max+1);
	for(int i=0; i<N; i++)
	{
		if(list[maxNum][i])
			printf("%d ", num[i]);
	}
}

--------------------------------------------------------------------------------------
역추적 함수를 활용:
https://naivep.tistory.com/10
https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/

num배열 내를 track배열 이라는 '전선'들로 이어붙여 연속적으로 연결하는 듯한 느낌..

#include <stdio.h>

int track[1001] = {0,};
int num[1001] = {0,};
void trace(int a)
{
	if(a==0)
		return;
	trace(track[a]);
	printf("%d ",num[a]);
}

int main()
{
	int dp[1001] = {0,};
	int N;
	scanf("%d", &N);
	for(int i=1; i<=N; i++)
	{
		scanf("%d", &num[i]); 
	}
	for(int i=2; i<=N; i++)
	{
		int temp = 0;
		for(int k=1; k<i; k++)
		{
			if(num[k]<num[i] && dp[k] >= dp[i])
			{
				dp[i] = dp[k] + 1;
				temp = k;
			}
		}
		track[i] = temp;
	}
	
	int max = -1;
	int maxNum=0;
	for(int i=1; i<=N; i++)
	{
		if(max<dp[i])
		{
			max = dp[i];
			maxNum = i;
		}
	}
	printf("%d\n",max+1);
	trace(maxNum);
}
