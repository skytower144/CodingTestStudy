//전깃줄 // LIS 응용문제 // 동적 계획법//

#include <stdio.h>
#include <stdlib.h>

typedef struct{
	int x;
	int y;
}point;
point temp[101];
void merge(point *a, int left, int mid, int right)
{
	int j = mid+1;
	int k = left;
	int ct = left;
	while(k<=mid && j<=right)
	{
		if(a[k].x > a[j].x)
			temp[ct++] = a[j++];
		else if(a[k].x <= a[j].x)
			temp[ct++] = a[k++];
	}
	if(k<=mid)
	{
		while(k<=mid)
			temp[ct++] = a[k++];
	}
	else if(j<=right)
	{
		while(j<=right)
			temp[ct++] = a[j++];
	}
	for(int k=left; k<=right; k++)
	{
		a[k] = temp[k];
	}
}
void partition(point *a, int left, int right)
{
	int mid;
	if(left<right)
	{
		mid = (left+right)/2;
		partition(a,left,mid);
		partition(a,mid+1,right);
		merge(a,left,mid,right);
	}
}

int main()
{
	int N;
	int list[101] = {0,};
	scanf("%d", &N);
	point *a = (point *)malloc(sizeof(point) * N);
	for(int i=0; i<N; i++)
	{
		scanf("%d %d", &a[i].x, &a[i].y);
	}
	partition(a,0,N-1);
	for(int i=1; i<N; i++)
	{
		for(int j=0; j<i; j++)
		{
			if(a[j].y < a[i].y && list[j]>=list[i])
				list[i] = list[j]+1;
		}
	}
	
	int max = list[0];
	for(int i=1; i<N; i++)
	{
		if(max<list[i])
			max = list[i];
	}
	printf("%d\n", N-(max+1));
		
	free(a);
	return 0;
}

-----------------------------------------------------------------------------------------------
퀵정렬 이용:

2차원 배열의 요소 크기 참고:
https://dojang.io/mod/page/view.php?id=310 

#include <stdio.h>
#include <stdlib.h>

int n;
int a[100][2];
int dp[100];

int max(int a, int b) {
	return a > b ? a : b;
}

int cmp(const void *a, const void *b) {
	int *x = (int *) a;
	int *y = (int *) b;

	if (x[0] < y[0]) return -1;			//x[0],y[0] 으로 설정..?
	if (x[0] > y[0]) return 1;
	return 0;
}

int main() {
	
	scanf("%d", &n);
	for (int i = 0; i < n; ++ i) {
		scanf("%d %d", &a[i][0], &a[i][1]);
	}
	
	qsort(a, n, sizeof(a[0]), cmp);			//퀵 정렬로 2차원 배열을 정렬하는것도 가능..
											//2차원 배열이므로 가로 한 줄의 크기가 a[0], 
											//즉 여기에서의 a[0]이란 a[0][0] + a[0][1]
	int maxv = 0;

	for (int i = 0; i < n; ++ i) {
		dp[i] = 1;
		for (int j = 0; j < i; ++ j) {
			if (a[j][1] < a[i][1]) {
				dp[i] = max(dp[i], dp[j] + 1);
			}
		}
		maxv = max(maxv, dp[i]);
	}
	
	int ans = n - maxv;
	printf("%d\n", ans);
	return 0;
}

----------------------------------------------------------------------------------------------
//카운팅 정렬
https://henrynoh.tistory.com/34

#include <stdio.h>

int a[501];
int dp[501];

int main() {
	
	int N;
	int j;
	scanf("%d", &N);
	for(int i=0; i<N; i++)
	{
		scanf("%d", &j);
		scanf("%d", &a[j]);
	}
	for(int i=0; i<=500; i++)
	{
		
		if(a[i] !=0)
		{
			for(int k=0; k<i; k++)
			{
				if(a[k] !=0)
				{
					if(a[k]<a[i] && dp[k] >= dp[i])
						dp[i] = dp[k]+1;
				}
			}
		}
	}
	int max = dp[0];
	for(int i=1; i<=500; i++)
	{
		if(dp[i] != 0)
		{
			if(max<dp[i])
				max = dp[i];
		}
	}
	printf("%d\n", N - (max+1));
	
	return 0;
}

