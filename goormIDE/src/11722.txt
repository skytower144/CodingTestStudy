// 가장 긴 감소하는 부분 수열 // 동적 계획법

// 가장 긴 증가하는 부분 수열을 반대로 적용시키면 된다. 수열 맨 끝에서부터 역으로 계산..
// 결과적으로 뒤집은 것이기 때문이다.

#include <stdio.h>

int main()
{
	int num[1001] = {0,};
	int dp[1001] = {0,};
	int N;
	scanf("%d", &N);
	for(int i=0; i<N; i++)
	{
		scanf("%d", &num[i]);
	}
	for(int i=N-2; i>=0; i--)
	{
		for(int k=N-1; k>i; k--)
		{
			if(num[k]<num[i] && dp[k] >= dp[i])
				dp[i] = dp[k]+1;
		}
	}
	int max=dp[0];
	for(int i=1; i<N; i++)
	{
		if(max<dp[i])
			max = dp[i];
	}
	printf("%d\n", max+1);
}
