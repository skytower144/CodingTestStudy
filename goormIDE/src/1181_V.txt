//단어정렬//

#include <stdio.h>
#include <string.h>

char temp[20001][51];
void merge(char a[][51], int left, int mid, int right)
{
	int i=left; int I;
	int t=left; int J;
	int j=mid+1;
	while(i<=mid && j<=right)
	{
		//printf("i: %d mid: %d j: %d right: %d\n",i,mid,j,right);
		I = strlen(a[i]);
		//printf("I: %d\n", I);
		J = strlen(a[j]);
		//printf("J: %d\n", J);
		if(I>J)
		{
			strcpy(temp[t],a[j]);
			t++; j++;
			//printf("A1\n");
		}
		else if(I<J)
		{
			strcpy(temp[t],a[i]);
			t++; i++;
			//printf("A2\n");
		}
		else
		{
			//printf("B1\n");
			for(int f=0; f<=I; f++)				//조건을 살짝 변경.
			{
				if(f==I)						//이 부분을 추가하는게 정말 어려웠다.
				{								//끝까지 가서 그래도 없을시 할수없이 i나j중 하나를 증가시키는 방식.
					strcpy(temp[t],a[i]);
					t++; i++;
					break;
				}
				else if(a[i][f] == a[j][f])
				{
					continue;
				}
				else if(a[i][f] > a[j][f])
				{
					strcpy(temp[t],a[j]);
					t++; j++;
					break;
				}
				else if(a[i][f] < a[j][f])
				{
					strcpy(temp[t],a[i]);
					t++; i++;
					break;
				}
			}
		}
		//printf("i: %d mid: %d j: %d right: %d\n",i,mid,j,right);
	}
	
	while(i<=mid)
	{
		strcpy(temp[t],a[i]);
		t++; i++;
	}
	
	while(j<=right)
	{
		strcpy(temp[t],a[j]);
		t++; j++;
	}

	for(int x=left; x<=right; x++)
	{
		strcpy(a[x],temp[x]);
	}
}

void partition(char a[][51], int left, int right)
{
	int mid;
	if(left<right)
	{
		mid = (left+right)/2;
		partition(a,left,mid);
		partition(a,mid+1,right);
		merge(a,left,mid,right);
	}
}

int main(void)
{
	char a[20001][51];
	int N;
	scanf("%d", &N);
	for(int i=0; i<N; i++)
	{
		scanf("%s", a[i]);
	}
	partition(a,0,N-1);
	for(int i=0; i<N; i++)
	{
		if(i>=1 && !strcmp(a[i],a[i-1]))			//중복은 출력 안하도록 앞뒤를 비교.
			continue;
		printf("%s\n", a[i]);
	}
	return 0;
}

-------------------------------------------------------------------------------------------
좀더 효율적인? 풀이)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char string[51];
    int length;					//좌표정렬 문제처럼 2개로 나눈다.
} str;

str sort[20001];

void merge(str* arr, int first, int mid, int last) {
    int i = first;
    int j = mid + 1;
    int k = first;

    while(i <= mid && j <= last) {
        if (arr[i].length < arr[j].length) {
            sort[k++] = arr[i++];
        } else if (arr[i].length > arr[j].length) {
            sort[k++] = arr[j++];
        } else {
            if (strcmp(arr[i].string, arr[j].string) < 0) {				//알파벳 정렬//
                sort[k++] = arr[i++];
            }
            else {
                sort[k++] = arr[j++];
            }
        }
    }
    if (i > mid) {
        while (j <= last)
            sort[k++] = arr[j++];
    }
    else {
        while (i <= mid)
            sort[k++] = arr[i++];
    }
    for (k = first; k <= last; k++) 
        arr[k] = sort[k];
}

void mergesort(str* arr, int first, int last) {
    int mid;
    if (first < last) {
        mid = (first + last) / 2;
        mergesort(arr, first, mid);
        mergesort(arr, mid + 1, last);
        merge(arr, first, mid, last);
    }
}

int main(void)
{
    int N;
    scanf("%d", &N);
    str arr[N];

    for(int i = 0; i < N; i++) {
        scanf("%s", arr[i].string);
        arr[i].length = strlen(arr[i].string);
    }

    mergesort(arr, 0, N - 1);

    printf("%s\n", arr[0].string);
    for (int i = 1; i < N; i++) {								//내가 한 방식이랑 동일
        if (strcmp(arr[i-1].string, arr[i].string) != 0)
            printf("%s\n", arr[i].string);
    }
    return 0;
}